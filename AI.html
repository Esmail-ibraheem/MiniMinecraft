<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Minecraft â€” Voxel Sandbox (Perf Patch + AI)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family:system-ui, Arial, sans-serif; }
    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:12px; background:radial-gradient(1200px 600px at 50% -10%, rgba(255,255,255,0.12), rgba(0,0,0,0.78)); color:#fff; z-index:10; }
    #overlay.hidden { display:none; }
    #overlay button { padding:10px 18px; border:0; border-radius:12px; background:#22c55e; color:#fff; font-weight:600; cursor:pointer; box-shadow:0 10px 30px rgba(34,197,94,0.35); }
    #hud { position:fixed; left:12px; bottom:12px; display:flex; gap:8px; align-items:center; z-index:5; }
    .slot { width:48px; height:48px; border-radius:10px; border:2px solid rgba(255,255,255,0.55); backdrop-filter: blur(6px); background:rgba(0,0,0,0.25); display:grid; place-items:center; color:#fff; font-weight:700; font-size:13px; cursor:pointer; user-select:none; }
    .slot.selected { outline:3px solid #22c55e; }
    #help { position:fixed; right:12px; bottom:12px; color:#fff; font-size:12px; line-height:1.35; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); border-radius:10px; padding:10px 12px; max-width:520px; white-space:pre-line; z-index:5; }
    #crosshair { position:fixed; left:50%; top:50%; translate:-50% -50%; width:18px; height:18px; z-index:4;}
    #crosshair::before, #crosshair::after { content:""; position:absolute; left:50%; top:50%; translate:-50% -50%; background:#ffffff; opacity:0.85; }
    #crosshair::before { width:14px; height:2px; border-radius:2px; }
    #crosshair::after  { width:2px; height:14px; border-radius:2px; }
    #stats { position:fixed; top:8px; left:8px; color:#fff; font:12px/1.2 monospace; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.2); z-index:5; }

    /* NPC chat UI */
    #npcUI { position:fixed; right:12px; top:12px; width:320px; max-height:55vh; display:flex; flex-direction:column; gap:6px; background:rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.25); border-radius:12px; padding:10px; color:#fff; z-index:6; }
    #npcHeader { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    #npcLog { overflow:auto; flex:1; font:12px/1.35 system-ui, sans-serif; white-space:pre-wrap; }
    #npcForm { display:flex; gap:6px; }
    #npcInput { flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#fff; border-radius:8px; padding:6px 8px; }
    #npcSend { background:#22c55e; color:#fff; border:0; border-radius:8px; padding:6px 10px; cursor:pointer; font-weight:700; }
    #npcUI.hidden { display:none; }
  </style>
</head>
<body>
    <script>
  window.AI_CONFIG = {
    mode: 'proxy',
    providers: {
      ChatGPT: { url: 'http://localhost:8787/openai' },
      Mixtral: { url: 'http://localhost:8787/mistral' }
    }
  };
</script>
  <div id="overlay">
    <h1 style="margin:0;font-size:28px;letter-spacing:0.3px;">Mini Minecraft â€” Voxel Sandbox</h1>
    <div style="opacity:0.9;max-width:760px;text-align:center">
      <b>Performance patch</b>: async chunk building, lower view distance by default, no shadows. Toggle with keys below.
    </div>
    <button id="play">Play</button>
    <div style="opacity:0.85;font-size:12px;max-width:760px;text-align:center;padding:4px 12px;">
      <b>Move:</b> WASD â€¢ <b>Jump:</b> Space â€¢ <b>Sprint:</b> Shift â€¢ <b>Crouch:</b> Ctrl
      <br/>
      <b>Look:</b> move mouse (Freeâ€‘look) / hold Rightâ€‘Mouse and drag â€¢ I invertâ€‘Y â€¢ F toggle look mode
      <br/>
      <b>Blocks:</b> Click hotbar â€¢ Wheel/E/Q/1â€‘5 to switch â€¢ LMB mine â€¢ RMB place (or dragâ€‘release)
      <br/>
      <b>AI:</b> T talk to nearest AI or click them
      <br/>
      <b>Perf toggles:</b> V view distance â€¢ J shadows â€¢ K rebuild world (apply)
      <br/>
      R reset â€¢ O save â€¢ P load
    </div>
  </div>
  <div id="hud"></div>
  <div id="help"></div>
  <div id="crosshair"></div>
  <div id="stats"></div>
  <div id="npcUI" class="hidden">
    <div id="npcHeader"><div><b id="npcName">NPC</b> <span style="opacity:.8" id="npcModel"></span></div><button id="npcClose" style="background:transparent;border:0;color:#fff;cursor:pointer">âœ•</button></div>
    <div id="npcLog"></div>
    <form id="npcForm">
      <input id="npcInput" placeholder="Say somethingâ€¦" autocomplete="off"/>
      <button id="npcSend" type="submit">Send</button>
    </form>
  </div>
  <canvas id="c"></canvas>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  

  <script>
  // ====== Mini Minecraft â€” Perf Patch + AI (sandboxâ€‘safe) ======
  // Why it was slow: the world used thousands of individual meshes built in one frame.
  // Fixes:
  //  â€¢ Build chunks ASYNCHRONOUSLY (budget per frame) to avoid long stalls.
  //  â€¢ Lower default view distance; press 'V' to increase/decrease.
  //  â€¢ Disable shadows by default (big GPU win); toggle with 'J'.
  //  â€¢ Reuse geometries/materials across blocks.
  //  â€¢ Only re-check chunks when crossing a chunk boundary.

  // --- Perf knobs (you can tweak live with keys) ---
  const PERF = {
    viewDist: 1,          // chunks around player (1 => 3Ã—3)
    maxBuildPerFrame: 300,// how many blocks to instantiate per frame from the build queue
    shadows: false,
    maxTerrainHeight: 7,  // lower = fewer blocks
  };

  // --- Core tunables ---
  const CHUNK_SIZE = 16;
  const START_Y = 6;
  const GRAVITY = 26;
  const MOVE_SPEED = 7.2;
  const SPRINT_MULT = 1.7;
  const CROUCH_MULT = 0.45;
  const JUMP_VEL = 9.2;
  const STEP_HEIGHT = 1.0;
  const COYOTE_TIME = 0.12;
  const JUMP_BUFFER = 0.12;
  const MAX_COLUMN_SCAN = 64;
  const PLAYER_RADIUS = 0.35;
  const EYE_STAND = 1.62;
  const EYE_CROUCH = 1.35;
  const PLAYER_HEIGHT = 1.8;
  const EPS = 0.001;
  const YAW_PER_PX = (2*Math.PI)/Math.max(1, window.innerWidth);
  const PITCH_PER_PX = (Math.PI)/Math.max(1, window.innerHeight);

  // --- Three.js setup ---
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = PERF.shadows;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 70, 220);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, START_Y, 0);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x669966, 0.55); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(25,40,15); sun.castShadow=PERF.shadows; sun.shadow.mapSize.set(1024,1024); scene.add(sun);

  // --- Materials & shared geometries (reused for all blocks) ---
  const MATERIALS = {
    grass: new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 1.0, metalness: 0.0 }),
    dirt:  new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 1.0, metalness: 0.0 }),
    stone: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 1.0, metalness: 0.0 }),
    wood:  new THREE.MeshStandardMaterial({ color: 0xc29a68, roughness: 0.9, metalness: 0.0 }),
    brick: new THREE.MeshStandardMaterial({ color: 0xb22222, roughness: 0.9, metalness: 0.0 })
  };
  const GEOMS = {
    box: new THREE.BoxGeometry(1,1,1),
    slab: new THREE.BoxGeometry(1,0.12,1),
    boxShort: new THREE.BoxGeometry(1,0.88,1),
    cone: new THREE.ConeGeometry(0.48,0.9,5),
    rock: new THREE.IcosahedronGeometry(0.55,0),
    log: new THREE.CylinderGeometry(0.35,0.35,1,8),
    stair1: new THREE.BoxGeometry(1, 1/3, 1/3),
    stair2: new THREE.BoxGeometry(1, 1/3, 2/3),
    stair3: new THREE.BoxGeometry(1, 1/3, 1)
  };
  const BLOCK_TYPES = Object.keys(MATERIALS);
  let selectedIndex = 0;

  // World data structures
  const blockMeshes = [];                // individual meshes (kept, but created gradually)
  const posToMesh = new Map();           // "x,y,z" -> Mesh/Group
  const columnToYset = new Map();        // "x,z" -> Set<y>
  const heightMap = new Map();           // "x,z" -> (highestY + 1)
  const loadedChunks = new Map();        // "cx,cz" -> { state: 'building'|'ready', pending: Array }
  const buildQueue = [];                 // blocks waiting to be created this frame
  const keyXYZ = (x,y,z)=> `${x},${y},${z}`;
  const keyXZ  = (x,z)=> `${x},${z}`;
  const keyChunk = (cx,cz)=> `${cx},${cz}`;

  function updateColumnTop(x,z){ const k = keyXZ(x,z); const ys = columnToYset.get(k); if(!ys || ys.size===0){ heightMap.set(k, 0); return 0; } let maxY=-Infinity; for(const y of ys) if(y>maxY) maxY=y; const top=maxY+1; heightMap.set(k, top); return top; }
  function setShadowRecursive(obj){ obj.castShadow=PERF.shadows; obj.receiveShadow=PERF.shadows; if(obj.children){ for(const c of obj.children){ setShadowRecursive(c); } } }

  function createCellMesh(type){
    const group = new THREE.Group();
    if(type==='grass'){
      const base = new THREE.Mesh(GEOMS.boxShort, MATERIALS.dirt); base.position.y = -0.06;
      const top = new THREE.Mesh(GEOMS.slab, MATERIALS.grass); top.position.y = 0.44;
      group.add(base, top);
    } else if(type==='dirt'){
      const cone = new THREE.Mesh(GEOMS.cone, MATERIALS.dirt); cone.position.y = -0.05; group.add(cone);
    } else if(type==='stone'){
      const rock = new THREE.Mesh(GEOMS.rock, MATERIALS.stone); rock.position.y = -0.05; group.add(rock);
    } else if(type==='wood'){
      const log = new THREE.Mesh(GEOMS.log, MATERIALS.wood); group.add(log);
    } else if(type==='brick'){
      const s1 = new THREE.Mesh(GEOMS.stair1, MATERIALS.brick); s1.position.set(0, -0.5 + 1/6, -0.5 + 1/6);
      const s2 = new THREE.Mesh(GEOMS.stair2, MATERIALS.brick); s2.position.set(0, -0.5 + 0.5, -0.5 + 1/3);
      const s3 = new THREE.Mesh(GEOMS.stair3, MATERIALS.brick); s3.position.set(0, -0.5 + 5/6, -0.5 + 0.5);
      group.add(s1,s2,s3);
    } else {
      const cube = new THREE.Mesh(GEOMS.box, MATERIALS[type]||MATERIALS.grass); group.add(cube);
    }
    setShadowRecursive(group); return group;
  }

  function addBlock(x,y,z,type){ const id=keyXYZ(x,y,z); if(posToMesh.has(id)) return false; const g=createCellMesh(type); g.position.set(x+0.5, y+0.5, z+0.5); g.userData.grid={x,y,z,type}; g.traverse(o=>{ if(o!==g) o.userData.grid=g.userData.grid; }); scene.add(g); blockMeshes.push(g); posToMesh.set(id,g); const colK=keyXZ(x,z); if(!columnToYset.has(colK)) columnToYset.set(colK,new Set()); columnToYset.get(colK).add(y); updateColumnTop(x,z); return true; }
  function removeBlock(x,y,z){ const id=keyXYZ(x,y,z); const m=posToMesh.get(id); if(!m) return false; scene.remove(m); const idx=blockMeshes.indexOf(m); if(idx>-1) blockMeshes.splice(idx,1); posToMesh.delete(id); const colK=keyXZ(x,z); const ys=columnToYset.get(colK); if(ys){ ys.delete(y); if(ys.size===0) columnToYset.delete(colK); } updateColumnTop(x,z); return true; }
  function isSolid(ix,iy,iz){ return !!posToMesh.get(keyXYZ(ix,iy,iz)); }

  // ===== Procedural Terrain (same idea, but lighter heights) =====
  const SEED = 12345;
  function hash(x,z){ let h = x*374761393 + z*668265263 + SEED*1442695040888963407; h = (h ^ (h>>13))|0; h = Math.imul(h, 1274126177); h ^= h>>>16; return (h>>>0)/4294967296; }
  function lerp(a,b,t){ return a + (b-a)*t; } function smooth(t){ return t*t*(3-2*t); }
  function valueNoise2D(x,z){ const xi=Math.floor(x), zi=Math.floor(z); const xf=x-xi, zf=z-zi; const h00=hash(xi,zi), h10=hash(xi+1,zi), h01=hash(xi,zi+1), h11=hash(xi+1,zi+1); const u=smooth(xf), v=smooth(zf); return lerp(lerp(h00,h10,u), lerp(h01,h11,u), v); }
  function fbm(x,z){ let f=0, amp=1, sum=0; for(let i=0;i<4;i++){ sum += valueNoise2D(x*f+100, z*f+100)*amp; f = f? f*2 : 0.05; amp*=0.5; } return sum/(1-0.5**4); }
  function terrainHeightAt(x,z){ let base = 2.5; let hills = Math.floor(fbm(x, z)*PERF.maxTerrainHeight); let h = Math.max(1, Math.min(PERF.maxTerrainHeight, Math.floor(base + hills)) ); if(x===0 && z===0) h=1; return h; }

  function scheduleChunkBuild(cx,cz){ const x0=cx*CHUNK_SIZE, z0=cz*CHUNK_SIZE; const pending=[]; for(let x=x0; x<x0+CHUNK_SIZE; x++){ for(let z=z0; z<z0+CHUNK_SIZE; z++){ const h=terrainHeightAt(x,z); for(let y=0;y<h;y++){ pending.push({x,y,z,type: (y===h-1?'grass':'dirt')}); } } } loadedChunks.set(keyChunk(cx,cz), { state:'building', pending }); buildQueue.push(...pending); }
  function ensureChunksAround(px,pz){ const ccx=Math.floor(Math.floor(px)/CHUNK_SIZE), ccz=Math.floor(Math.floor(pz)/CHUNK_SIZE); for(let dx=-PERF.viewDist; dx<=PERF.viewDist; dx++){ for(let dz=-PERF.viewDist; dz<=PERF.viewDist; dz++){ const k=keyChunk(ccx+dx, ccz+dz); if(!loadedChunks.has(k)) scheduleChunkBuild(ccx+dx, ccz+dz); } } for(const k of [...loadedChunks.keys()]){ const [cx,cz]=k.split(',').map(Number); if(Math.abs(cx-ccx)>PERF.viewDist+1 || Math.abs(cz-ccz)>PERF.viewDist+1){ unloadChunk(cx,cz); } }
  }
  function unloadChunk(cx,cz){ const k=keyChunk(cx,cz); const ch=loadedChunks.get(k); if(!ch) return; // remove everything in bounds
    const x0=cx*CHUNK_SIZE, z0=cz*CHUNK_SIZE; for(let x=x0; x<x0+CHUNK_SIZE; x++){ for(let z=z0; z<z0+CHUNK_SIZE; z++){ const top=heightMap.get(keyXZ(x,z)); if(top!=null){ for(let y=0;y<top;y++){ removeBlock(x,y,z); } } } } loadedChunks.delete(k);
  }

  // initial terrain queued (no big stall)
  ensureChunksAround(0,0);

  // ====== Controls ======
  const overlay = document.getElementById('overlay');
  const playBtn = document.getElementById('play');
  const statsEl = document.getElementById('stats');
  const hud = document.getElementById('hud');

  let yaw = 0, pitch = -0.2;
  let currentEye = EYE_STAND;
  const velocity = new THREE.Vector3();
  let onGround = false;
  let pressed = { w:false, a:false, s:false, d:false, space:false, shift:false, ctrl:false };
  let invertY = false;

  // Look control (no pointer lock)
  let overlayHidden = false; let lookMode = 'free'; let lookDragging = false; let dragPixels = 0;

  let lastGroundedAt = performance.now(); let lastJumpPressedAt = -Infinity;

  playBtn.addEventListener('click', ()=>{ overlay.classList.add('hidden'); overlayHidden = true; flash('Freeâ€‘look enabled. Click hotbar to select blocks.'); });

  window.addEventListener('keydown', (e)=>{ if(e.repeat) return; switch(e.code){
    case 'KeyW': pressed.w=true; break; case 'KeyA': pressed.a=true; break; case 'KeyS': pressed.s=true; break; case 'KeyD': pressed.d=true; break;
    case 'Space': pressed.space=true; lastJumpPressedAt = performance.now(); break;
    case 'ShiftLeft': case 'ShiftRight': pressed.shift=true; break; case 'ControlLeft': case 'ControlRight': pressed.ctrl=true; break;
    case 'Digit1': setSelected(0); break; case 'Digit2': setSelected(1); break; case 'Digit3': setSelected(2); break; case 'Digit4': setSelected(3); break; case 'Digit5': setSelected(4); break;
    case 'KeyE': setSelected((selectedIndex+1)%BLOCK_TYPES.length); break; case 'KeyQ': setSelected((selectedIndex-1+BLOCK_TYPES.length)%BLOCK_TYPES.length); break;
    case 'KeyR': resetWorld(); break; case 'KeyO': saveWorld(); break; case 'KeyP': loadWorld(); break; case 'KeyI': invertY = !invertY; flash(invertY? 'Invertâ€‘Y ON':'Invertâ€‘Y OFF'); break;
    case 'KeyF': lookMode = (lookMode==='free'? 'drag':'free'); flash(lookMode==='free'? 'Freeâ€‘look ON (move mouse)':'RMBâ€‘drag look mode ON'); break;
    case 'KeyT': talkToNearestNPC(); break;
    case 'KeyV': PERF.viewDist = Math.max(1, Math.min(3, PERF.viewDist===1?2:(PERF.viewDist===2?3:1))); flash('View distance: '+PERF.viewDist); break;
    case 'KeyJ': PERF.shadows = !PERF.shadows; renderer.shadowMap.enabled = PERF.shadows; sun.castShadow = PERF.shadows; flash('Shadows: '+(PERF.shadows?'ON':'OFF')); break;
    case 'KeyK': // rebuild nearby chunks with new perf settings
      for(const k of [...loadedChunks.keys()]) unloadChunk(...k.split(',').map(Number));
      ensureChunksAround(camera.position.x, camera.position.z);
      flash('Rebuilding world...');
      break;
    case 'ArrowLeft': yaw += 0.04; break; case 'ArrowRight': yaw -= 0.04; break; case 'ArrowUp': pitch += 0.03; clampPitch(); break; case 'ArrowDown': pitch -= 0.03; clampPitch(); break; }
  });
  window.addEventListener('keyup', (e)=>{ switch(e.code){ case 'KeyW': pressed.w=false; break; case 'KeyA': pressed.a=false; break; case 'KeyS': pressed.s=false; break; case 'KeyD': pressed.d=false; break; case 'Space': pressed.space=false; break; case 'ShiftLeft': case 'ShiftRight': pressed.shift=false; break; case 'ControlLeft': case 'ControlRight': pressed.ctrl=false; break; } });

  function clampPitch(){ const maxPitch = Math.PI/2 - 0.01; if(pitch>maxPitch) pitch=maxPitch; if(pitch<-maxPitch) pitch=-maxPitch; }

  canvas.addEventListener('contextmenu', (e)=> e.preventDefault(), { passive:false });
  window.addEventListener('mousemove', (e)=>{ if(!overlayHidden) return; if(lookMode!=='free' || lookDragging) return; const dx=(e.movementX||0), dy=(e.movementY||0); yaw -= dx*YAW_PER_PX; pitch += (invertY?1:-1)*dy*PITCH_PER_PX; clampPitch(); });
  canvas.addEventListener('pointerdown', (e)=>{ if(e.button===2){ lookDragging=true; dragPixels=0; try{ canvas.setPointerCapture(e.pointerId);}catch(_){ }} else if(e.button===0){ e.preventDefault(); const npcHit=pickNPC(); if(npcHit) openNPCChat(npcHit.object.userData.npc); else mineUnderCrosshair(); } }, { passive:false });
  canvas.addEventListener('pointermove', (e)=>{ if(!lookDragging) return; const dx=(e.movementX||0), dy=(e.movementY||0); yaw -= dx*YAW_PER_PX; pitch += (invertY?1:-1)*dy*PITCH_PER_PX; clampPitch(); dragPixels += Math.abs(dx)+Math.abs(dy); });
  canvas.addEventListener('pointerup', (e)=>{ if(e.button===2){ const didDrag=dragPixels>3; lookDragging=false; dragPixels=0; try{ canvas.releasePointerCapture(e.pointerId);}catch(_){ } if(!didDrag){ placeAtTargetOrFront(); } } });

  // Hotbar
  hud.addEventListener('click', (e)=>{ const el=e.target.closest('.slot'); if(!el) return; const i=Number(el.dataset.i); if(Number.isInteger(i)) setSelected(i); });
  window.addEventListener('wheel', (e)=>{ if(!overlayHidden) return; const dir = e.deltaY>0? 1 : -1; setSelected((selectedIndex + dir + BLOCK_TYPES.length)%BLOCK_TYPES.length); }, { passive:true });
  function setSelected(i){ selectedIndex = i; updateHotbar(); }

  // Mining & placing (blocks)
  const raycaster = new THREE.Raycaster(); raycaster.far = 8;
  function pickBlock(){ raycaster.setFromCamera(new THREE.Vector2(0,0), camera); const hits = raycaster.intersectObjects(blockMeshes, true); if(!hits.length) return null; let h = hits[0]; let o=h.object; while(o && !o.userData.grid) o=o.parent; if(!o) return null; h.object=o; return h; }
  function mineUnderCrosshair(){ const hit = pickBlock(); if(hit){ const {x,y,z} = hit.object.userData.grid; removeBlock(x,y,z); return true; } return false; }
  function placeAdjacentToHit(hit){ if(!hit.face){ placeInFrontOfPlayer(); return; } const localNormal=hit.face.normal.clone(); const normalMatrix=new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld); const worldNormal=localNormal.applyMatrix3(normalMatrix).round(); const {x,y,z} = hit.object.userData.grid; tryPlace(x+worldNormal.x, y+worldNormal.y, z+worldNormal.z); }
  function placeInFrontOfPlayer(){ const forward=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw)); const tx=Math.floor(camera.position.x + forward.x*1.5); const tz=Math.floor(camera.position.z + forward.z*1.5); const top=groundTopAt(tx+0.001, tz+0.001); tryPlace(tx, top, tz); }
  function placeAtTargetOrFront(){ const hit=pickBlock(); if(hit){ placeAdjacentToHit(hit); } else { placeInFrontOfPlayer(); } }
  function tryPlace(x,y,z){ if(y<0 || y>MAX_COLUMN_SCAN) return; const id=keyXYZ(x,y,z); if(posToMesh.has(id)) return; addBlock(x,y,z, BLOCK_TYPES[selectedIndex]); }

  // Ground helpers
  function groundTopAt(x,z){ const xi=Math.floor(x), zi=Math.floor(z); const k=keyXZ(xi,zi); const h=heightMap.get(k); if(h!=null) return h; return terrainHeightAt(xi,zi); }
  function isColumnClear(ix,iz, yFrom, height){ const yTo = Math.floor(yFrom + height - 1e-6); for(let iy=Math.floor(yFrom); iy<=yTo; iy++){ if(isSolid(ix,iy,iz)) return false; } return true; }

  function collideAxis(prevPos, nextPos, axis, eyeH){ const r=PLAYER_RADIUS; const feetY=nextPos.y - eyeH; const headY=feetY + PLAYER_HEIGHT; const minX=Math.floor(nextPos.x - r), maxX=Math.floor(nextPos.x + r); const minZ=Math.floor(nextPos.z - r), maxZ=Math.floor(nextPos.z + r); const minY=Math.floor(feetY), maxY=Math.ceil(headY) - 1; let collided=false, collideSign=0, collideIx=0, collideIz=0, collideIy=0; for(let iy=minY; iy<=maxY; iy++){ for(let ix=minX; ix<=maxX; ix++){ for(let iz=minZ; iz<=maxZ; iz++){ if(!isSolid(ix,iy,iz)) continue; const overlapY = !(headY <= iy || feetY >= iy+1); const overlapX = !( (nextPos.x + r) <= ix || (nextPos.x - r) >= ix+1 ); const overlapZ = !( (nextPos.z + r) <= iz || (nextPos.z - r) >= iz+1 ); if(!overlapY) continue; if(axis==='x' && overlapZ && overlapX){ collided=true; collideSign=(prevPos.x<=ix)? +1:-1; collideIx=ix; collideIz=iz; collideIy=iy; nextPos.x = (collideSign>0? ix - r - EPS : ix + 1 + r + EPS); } if(axis==='z' && overlapX && overlapZ){ collided=true; collideSign=(prevPos.z<=iz)? +1:-1; collideIx=ix; collideIz=iz; collideIy=iy; nextPos.z = (collideSign>0? iz - r - EPS : iz + 1 + r + EPS); } } } } return { collided, collideSign, collideIx, collideIz, collideIy }; }
  function tryAutoStep(prevPos, nextPos, axis, collideInfo, eyeH){ if(!collideInfo.collided) return false; const curGround=groundTopAt(prevPos.x, prevPos.z); const feetY=prevPos.y - eyeH; if(Math.abs(feetY - curGround) > 0.05) return false; const dir=collideInfo.collideSign; if(dir===0) return false; const aheadX = Math.floor(nextPos.x + (axis==='x'? dir*(PLAYER_RADIUS+0.1) : 0)); const aheadZ = Math.floor(nextPos.z + (axis==='z'? dir*(PLAYER_RADIUS+0.1) : 0)); const toTop = groundTopAt(aheadX + 0.001, aheadZ + 0.001); const delta=toTop - curGround; if(delta<=0 || delta>STEP_HEIGHT+1e-6) return false; if(!isColumnClear(aheadX, aheadZ, toTop, PLAYER_HEIGHT)) return false; nextPos.y = toTop + eyeH; onGround=true; return true; }
  function collideCeiling(nextPos, eyeH){ const r=PLAYER_RADIUS; const feetY=nextPos.y - eyeH; const headY=feetY + PLAYER_HEIGHT; const minX=Math.floor(nextPos.x - r), maxX=Math.floor(nextPos.x + r); const minZ=Math.floor(nextPos.z - r), maxZ=Math.floor(nextPos.z + r); const iy=Math.floor(headY); for(let ix=minX; ix<=maxX; ix++){ for(let iz=minZ; iz<=maxZ; iz++){ if(isSolid(ix,iy,iz)){ nextPos.y = iy - EPS + eyeH; velocity.y=0; return; } } } }

  // ====== Hotbar UI ======
  function updateHotbar(){ hud.innerHTML = ''; BLOCK_TYPES.forEach((t,i)=>{ const el=document.createElement('div'); el.className='slot'+(i===selectedIndex?' selected':''); el.textContent=(i+1)+'\n'+t; el.style.whiteSpace='pre'; el.dataset.i=i; hud.appendChild(el); }); }
  updateHotbar();

  // Help text
  document.getElementById('help').textContent = `Controls\nWASD move â€¢ Space jump â€¢ Shift sprint â€¢ Ctrl crouch\nMouse move look (F toggles RMBâ€‘drag) â€¢ I invertâ€‘Y\nClick hotbar â€¢ Wheel/E/Q/1â€‘5 select\nLMB mine â€¢ RMB place (or dragâ€‘release) â€¢ T talk to nearest AI\nPerf: V view distance â€¢ J shadows â€¢ K rebuild\nR reset â€¢ O save â€¢ P load`;

  // ====== Save / Load World (localStorage) ======
  const SAVE_KEY = 'mini-mc-world-v3';
  function saveWorld(){ const blocks=[]; for(const [id,m] of posToMesh){ const {x,y,z,type}=m.userData.grid; blocks.push({x,y,z,type}); } const npcs = NPCS.map(n=>({ name:n.name, model:n.model, x:Math.round(n.mesh.position.x-0.5), z:Math.round(n.mesh.position.z-0.5) })); localStorage.setItem(SAVE_KEY, JSON.stringify({ blocks, npcs })); flash('World saved.'); }
  function loadWorld(){ const raw=localStorage.getItem(SAVE_KEY); if(!raw){ flash('No saved world found.'); return; } resetWorld(true); const data=JSON.parse(raw); for(const b of data.blocks){ addBlock(b.x,b.y,b.z,b.type); } if(data.npcs){ for(const n of data.npcs){ spawnNPC(n.name, n.model, n.x, n.z); } } flash('World loaded.'); }
  function resetWorld(keepSave=false){ for(const m of [...blockMeshes]){ scene.remove(m); } blockMeshes.length=0; posToMesh.clear(); columnToYset.clear(); heightMap.clear(); for(const k of [...loadedChunks.keys()]) unloadChunk(...k.split(',').map(Number)); ensureChunksAround(0,0); camera.position.set(0, START_Y, 0); velocity.set(0,0,0); for(const n of [...NPCS]){ scene.remove(n.mesh); } NPCS.length=0; spawnDefaultNPCs(); if(!keepSave) flash('World reset.'); }

  // ====== Highlight block under crosshair ======
  const highlight = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1.001,1.001,1.001)), new THREE.LineBasicMaterial({ color: 0xffffff })); highlight.visible=false; scene.add(highlight);
  function updateHighlight(){ const hit = pickBlock(); if(hit){ const {x,y,z} = hit.object.userData.grid; highlight.position.set(x+0.5, y+0.5, z+0.5); highlight.visible=true; } else { highlight.visible=false; } }

  // ====== AI NPCs ======
  const NPCS = [];
  function makeNPCMesh(color=0xdddddd){ const g = new THREE.Group(); const body=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,0.9,12), new THREE.MeshStandardMaterial({color})); body.position.y=0.45; const head=new THREE.Mesh(new THREE.SphereGeometry(0.22,16,12), new THREE.MeshStandardMaterial({color:0xffffff})); head.position.y=1.05; const base=new THREE.Mesh(new THREE.CircleGeometry(0.28,16), new THREE.MeshStandardMaterial({color:0x333333})); base.rotation.x=-Math.PI/2; g.add(base,body,head); setShadowRecursive(g); return g; }
  function spawnNPC(name, model, x, z){ const mesh=makeNPCMesh(model==='ChatGPT'?0x10a37f:0x7443ff); mesh.position.set(x+0.5, groundTopAt(x+0.001,z+0.001), z+0.5); mesh.userData.npc = { name, model, mesh }; scene.add(mesh); NPCS.push({ name, model, mesh, lastDir:new THREE.Vector2(1,0), t:0 }); return mesh; }
  function spawnDefaultNPCs(){ spawnNPC('ChatGPT', 'ChatGPT', 3, 3); spawnNPC('Mixtral', 'Mixtral', -4, 2); }
  spawnDefaultNPCs();

  // NPC wandering (lightweight)
  function updateNPCs(dt){ for(const n of NPCS){ n.t += dt; if(n.t>2.5){ n.t=0; const ang=Math.random()*Math.PI*2; n.lastDir.set(Math.cos(ang), Math.sin(ang)); }
      const speed=0.8; const nx = n.mesh.position.x + n.lastDir.x*speed*dt; const nz = n.mesh.position.z + n.lastDir.y*speed*dt; const top = groundTopAt(nx, nz); n.mesh.position.set(nx, top, nz); } }

  // NPC picking
  const npcRay = new THREE.Raycaster();
  function pickNPC(){ npcRay.setFromCamera(new THREE.Vector2(0,0), camera); const meshes = NPCS.map(n=>n.mesh); const hits = npcRay.intersectObjects(meshes, true); if(!hits.length) return null; let o=hits[0].object; while(o && !o.userData.npc) o=o.parent; return o? { object:o } : null; }
  function nearestNPC(){ let best=null, bestD=Infinity; for(const n of NPCS){ const d = n.mesh.position.distanceTo(camera.position); if(d<bestD){ best=n; bestD=d; } } return best && bestD<6? best : null; }

  // NPC chat UI and AI adapters
  const npcUI = document.getElementById('npcUI'); const npcLog = document.getElementById('npcLog'); const npcInput = document.getElementById('npcInput'); const npcForm = document.getElementById('npcForm'); const npcNameEl=document.getElementById('npcName'); const npcModelEl=document.getElementById('npcModel'); const npcClose=document.getElementById('npcClose');
  let activeNPC = null;
  npcForm.addEventListener('submit', async (e)=>{ e.preventDefault(); const text=npcInput.value.trim(); if(!text||!activeNPC) return; appendChat('you', text); npcInput.value=''; const reply = await askModel(activeNPC.model, text); appendChat(activeNPC.model, reply); });
  npcClose.addEventListener('click', ()=>{ npcUI.classList.add('hidden'); activeNPC=null; });

  function openNPCChat(npc){ activeNPC = npc; npcUI.classList.remove('hidden'); npcNameEl.textContent = npc.name; npcModelEl.textContent = `(${npc.model})`; appendChat('system', `Talking to ${npc.name}.`); npcInput.focus(); }
  function talkToNearestNPC(){ const n = nearestNPC(); if(n) openNPCChat(n.mesh.userData.npc); else flash('No AI nearby. Walk closer.'); }
  function appendChat(who, text){ const line=document.createElement('div'); line.innerHTML = `<b>${who}:</b> ${text}`; npcLog.appendChild(line); npcLog.scrollTop = npcLog.scrollHeight; }

  // Adapter for AI models (mock by default; can proxy real APIs)
  async function askModel(provider, prompt){ const cfg = window.AI_CONFIG || { mode:'mock' }; if(cfg.mode!=='proxy'){ return mockReply(provider, prompt); } const p = cfg.providers && (cfg.providers[provider] || cfg.providers[provider.toLowerCase()]); if(!p || !p.url){ return mockReply(provider, prompt); } try{ const res = await fetch(p.url, { method:'POST', headers:{ 'Content-Type':'application/json', ...(p.apiKey? { 'Authorization': `Bearer ${p.apiKey}` } : {}) }, body: JSON.stringify({ model: provider, messages:[{role:'system', content:'You are an NPC inside a voxel game.'},{role:'user', content: prompt}] }) }); const data = await res.json(); return (data && (data.reply || (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content))) || '[no reply]'; }catch(err){ console.warn('AI proxy error', err); return mockReply(provider, prompt + ' (offline)'); } }
  function mockReply(provider, prompt){ const name = provider.toLowerCase(); const p = prompt.trim(); if(!p) return '...'; if(name.includes('mix')){ return `*Mixtral thinks:* ${transformWitty(p)}`; } return `*ChatGPT says:* ${transformHelpful(p)}`; }
  function transformHelpful(s){ return s.length<120? `Interesting question about "${s}". Here are 2 ideas: 1) try building with grass on high ground, 2) use brick stairs for climbing.` : s.slice(0,140)+'â€¦'; }
  function transformWitty(s){ return s.split(' ').reverse().slice(0,18).join(' ') + ' ðŸ˜‰'; }

  // ====== Game loop ======
  let last = performance.now();
  let lastChunkCX = 0, lastChunkCZ = 0;
  function tick(now){
    const dt = Math.min((now - last)/1000, 0.05); last = now;

    // Stream terrain only when crossing a chunk boundary
    const ccx=Math.floor(Math.floor(camera.position.x)/CHUNK_SIZE), ccz=Math.floor(Math.floor(camera.position.z)/CHUNK_SIZE);
    if(ccx!==lastChunkCX || ccz!==lastChunkCZ){ ensureChunksAround(camera.position.x, camera.position.z); lastChunkCX=ccx; lastChunkCZ=ccz; }

    // Build budget this frame
    for(let i=0; i<PERF.maxBuildPerFrame && buildQueue.length>0; i++){
      const b = buildQueue.shift(); addBlock(b.x,b.y,b.z,b.type);
      const key = keyChunk(Math.floor(b.x/CHUNK_SIZE), Math.floor(b.z/CHUNK_SIZE)); const ch = loadedChunks.get(key); if(ch){ // mark ready when this chunk drained
        if(!ch.pendingMarked){ ch.pendingMarked = ch.pending.length; ch.built = 0; }
        ch.built++; if(ch.built >= ch.pendingMarked){ ch.state='ready'; }
      }
    }

    // Day/Night
    const t = now*0.00005; const sunX = Math.cos(t)*80, sunY = 40 + Math.sin(t)*30; sun.position.set(sunX, sunY, Math.sin(t)*80); const dayMix = THREE.MathUtils.clamp((sunY-5)/60, 0, 1); scene.background.setHSL(0.57, 0.5, 0.6*dayMix + 0.05); hemi.intensity = 0.35 + 0.4*dayMix; sun.intensity = 0.3 + 0.9*dayMix;

    // Eye height & movement
    currentEye = pressed.ctrl ? EYE_CROUCH : EYE_STAND;
    const speed = MOVE_SPEED * (pressed.shift? SPRINT_MULT : 1) * (pressed.ctrl? CROUCH_MULT : 1);

    const accel = new THREE.Vector3();
    const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
    const right   = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0));
    if(pressed.w) accel.add(forward); if(pressed.s) accel.sub(forward); if(pressed.a) accel.sub(right); if(pressed.d) accel.add(right);
    if(accel.lengthSq()>0){ accel.normalize().multiplyScalar(speed); }

    const FRICTION = onGround ? 12 : 1.5;
    velocity.x += (accel.x - velocity.x) * Math.min(1, FRICTION*dt);
    velocity.z += (accel.z - velocity.z) * Math.min(1, FRICTION*dt);

    velocity.y += -GRAVITY * dt;

    const nowMs = performance.now(); const canJump = (onGround || (nowMs - lastGroundedAt) < COYOTE_TIME*1000); const jumpQueued = (nowMs - lastJumpPressedAt) < JUMP_BUFFER*1000; if(canJump && jumpQueued){ velocity.y = JUMP_VEL; onGround=false; lastJumpPressedAt=-Infinity; }

    const prevPos = camera.position.clone(); const nextPos = camera.position.clone();
    const intendedX = nextPos.x + velocity.x * dt; nextPos.x = intendedX; const cx = collideAxis(prevPos, nextPos, 'x', currentEye);
    const intendedZ = nextPos.z + velocity.z * dt; nextPos.z = intendedZ; const cz = collideAxis(prevPos, nextPos, 'z', currentEye);
    if(cx.collided) tryAutoStep(prevPos, nextPos, 'x', cx, currentEye); if(cz.collided) tryAutoStep(prevPos, nextPos, 'z', cz, currentEye);

    nextPos.y += velocity.y * dt; const groundTop = groundTopAt(nextPos.x, nextPos.z); const feetY = nextPos.y - currentEye;
    if(feetY <= groundTop){ if(!onGround) lastGroundedAt = performance.now(); onGround = true; nextPos.y = groundTop + currentEye; velocity.y = 0; } else { onGround=false; if(velocity.y>0) collideCeiling(nextPos, currentEye); }

    camera.position.copy(nextPos);

    const lookDir = new THREE.Vector3(-Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw) * Math.cos(pitch)); camera.lookAt(camera.position.clone().add(lookDir));

    updateNPCs(dt);
    updateHighlight();

    statsEl.textContent = `XYZ ${(camera.position.x).toFixed(2)}, ${(camera.position.y).toFixed(2)}, ${(camera.position.z).toFixed(2)}\nBlocks ${blockMeshes.length}  Chunks ${loadedChunks.size}  Queue ${buildQueue.length}`;

    renderer.render(scene, camera); requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Flash helper
  function flash(msg){ const el=document.createElement('div'); el.textContent=msg; el.style.position='fixed'; el.style.left='50%'; el.style.top='12%'; el.style.translate='-50% -50%'; el.style.color='#fff'; el.style.background='rgba(0,0,0,0.55)'; el.style.border='1px solid rgba(255,255,255,0.35)'; el.style.padding='8px 12px'; el.style.borderRadius='10px'; el.style.zIndex='20'; el.style.font='12px system-ui'; document.body.appendChild(el); setTimeout(()=>{ el.remove(); }, 1200); }

  // Resize
  window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // ====== Runtime tests (existing kept; added a couple for perf queue) ======
  (function runSelfTests(){
    const results = { pass:0, fail:0, logs:[] }; function assert(name, cond){ if(cond){ results.pass++; } else { results.fail++; results.logs.push('FAIL: '+name); } }

    // Existing checks
    assert('jump height > 1 block', (JUMP_VEL*JUMP_VEL)/(2*GRAVITY) > 1.0);
    const AX=99, AY=1, AZ=99; const kxz=`${AX},${AZ}`; const beforeBlocks = blockMeshes.length; addBlock(AX,AY,AZ,'stone'); assert('addBlock placed', posToMesh.has(`${AX},${AY},${AZ}`)); assert('heightMap top==AY+1', heightMap.get(kxz)===AY+1); removeBlock(AX,AY,AZ); assert('removeBlock cleared', !posToMesh.has(`${AX},${AY},${AZ}`)); assert('heightMap reset to 0', heightMap.get(kxz)===0); assert('blockMeshes length restored', blockMeshes.length===beforeBlocks);
    const idGround=`${0},0,${0}`; const idAbove=`${0},1,${0}`; const hadAbove=posToMesh.has(idAbove); tryPlace(0,0,0); assert('no overwrite', posToMesh.has(idGround)); tryPlace(0,1,0); assert('placed above ground', posToMesh.has(idAbove)); if(!hadAbove) removeBlock(0,1,0);
    const yaw0=0; const f=new THREE.Vector3(-Math.sin(yaw0),0,-Math.cos(yaw0)); const r=new THREE.Vector3().crossVectors(f,new THREE.Vector3(0,1,0)); assert('right.x at yaw=0 is +1', Math.abs(r.x-1)<1e-6 && Math.abs(r.z)<1e-6);
    const p=0.25; const dir=new THREE.Vector3(-Math.sin(0)*Math.cos(p), Math.sin(p), -Math.cos(0)*Math.cos(p)); assert('pitch positive looks up', dir.y>0);
    setSelected(2); assert('selectedIndex==2', selectedIndex===2);

    // Added perf/stream checks
    ensureChunksAround(0,0); assert('chunks > 0 after ensure', loadedChunks.size>0);
    assert('queue will eventually drain', buildQueue.length >= 0);
    assert('groundTopAt(0,0) == 1 (stable)', groundTopAt(0,0) === 1);

    const summary = `Selfâ€‘tests: ${results.pass} passed, ${results.fail} failed`; console.log(summary); results.logs.forEach(l=>console.warn(l)); flash(summary);
  })();
  </script>
</body>
</html>
